# 27강 - 상속
## 상속 (inheritance)
1. 기존에 사용중인 클래스의 필드중 새롭게 만들 클래스에서 필요한 것들이 있다면 상속을 받아서 그대로 사용한다
2. 여러클래스를 선언할 때 중복되는 기능들이 존재한다면 공통 기능들을 담아놓을 클래스를 선언한다

- 부모클래스 ,상위클래스, 슈퍼클래스, 기반클래스 (동물) : 필드를 전달하는 쪽
- 자식클래스, 하위클래스, 서브클래스, 파생클래스 (돼지,말) : 필드를 전달받는 쪽

```
class A:
    A필드
class B(A):
    A,B필드
```

### 다중상속
- 부모 클래스가 한개가 아닌 여러개이다. 이러한 기법을 다중 상속이라 한다.
```
class A:
    A필드
class B(A,C,D):
    A,B필드
```

#### 모호성
- 여러부모의 필드중 같은 이름의 필드를 자식 클래스에서 사용한다면, 어느 부모의 필드인지 알 수가 없기 떄문에 이러한 성질을 모호성이라 한다.

### 생성자
- 부모클래스에 생성자가 선언되어있고, 자식클래스에서 기본생성자가 있다면, 부모 클래스 생성자를 자동으로 호출해준다. 하지만 자식 클래스에서 생성자를 직접 선언하면 부모 생성자를 자식 생성자에서 직접 호출해주어야한다.

#### 자식클래스에 생성자가 있을 때
- 부모에 있는 필드와 자식에서 필요한 필드가 있을 때, 부모생성자를 호출하여 부모 필드를 초기화 해주고 추가된 자식 필드를 추가로 초기화해주어야할 때

#### 자식클래스에 생성자가 없을때 (기본 생성자만 있을때)
- 부모의 필드외에 추가적인 필드가 없을 때, 부모 생성자를 그대로 사용한다


## 다형성(polymorphism)
- 재정의 : 부모필드에서 수정하고 싶은 메소드는 자식 필드에서 같은 이름으로 재선언 할 수 있다.
    - 항상 부모생성자가 먼저 호출되어 부모 필드가 메모리에 할당된다.
    - 먼저 할당된 부모 필드에 a라는 메소드가 있다면, 나중에 할당되는 자식 필드의 a메소드 기능(소스코드의 주소값)으로 덮어씌워진다.

    ```
    data=10:부모
    data=20:자식
    print(data)==20 출력
    ```
```py
#%% interitance
class A : 
    def __init__(self,data=10):
        self.data = data
        print("부모 생성자 호출")

    def printData(self):
        print(self.data)
    
    def show(self):
        print("부모 메소드")
    

class B(A):
    def __init__(self,data,data2):
        # A.__init__(self,data)
        super().__init__(data) # super로 부모생성자를 호출하는데, self까지 넘겨줌
        self.data2=data2

    def printData2(self):
        print(self.data,self.data2)

    #Overrideing 재정의, 다형성
    def printData(self):
        print(self.data,self.data2)

# b = B()
# b.printData() # 자식생성자가 부모 생성자를 자동으로 호출함
# b.show()

b=B(30,20)
b.printData()
b.printData2()
```