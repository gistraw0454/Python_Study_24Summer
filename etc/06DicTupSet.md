# 리스트와 딕셔너리 ?
> 리스트 정의 : `리스트명 = [값1,값2,...]`

> 딕셔너리 정의 : `딕셔너리명 = {키1:값1, 키2:값2,...}`  
딕셔너리 항목 삽입/수정 : `딕셔너리명[키]=값`  
딕셔너리 항목 삭제 : `del 딕셔너리명[키]`  
- `len()`, `in`, `not in`, `==` 가능 

딕셔너리는 리스트와 달리, `pop`으로 항목을 삭제해도 `dic[1]`의 요소가 바뀌지 않는다.
- `dic[1]`의 1은 인덱스가 아니라 22를 key이기 때문

항목값 접근방법
- 리스트 : `lst[0]`   : 인덱스로 접근
- 딕셔너리 : `dic['one']` : key로 접근

## 딕셔너리와 연산자 ?

```py
person = {'이름': '홍길동', '나이': 26, '몸무게': 82}
person2 = {'이름': '홍길동', '나이': 26}

len(person)

'이름' in person

'직업' not in person

'홍길동' not in person

'x' in 'aeiou'
# >> False

person == person2 
# >> True    다른 비교연산은 불가
```

# 튜플 ?
- 여러개의 요소를 가지는 컬렉션 자료형
- <ins>한번 정해진 요소의 순서를 바꿀 수 없고, 내부 객체 변경과 삭제가 불가능 : 불변성</ins>
- 함수의 반환문에서 여러 객체를 반환 할 수 있는데 이때 반환되는 자료형이 튜플형이다.

|튜플 생성 방법| 명령어 |
|--|--|
|빈 튜플 만들기| `tuple0=()` |
|하나의 요소를 가진 튜플 만들기| `tuple1=(1,)` # 반드시 쉼표 써야함!!!!! 안쓰면 정수형으로 처리됨 |
|기본적인 튜플 만들기| `tuple2=(1,2,3,4)` |
|간단한 방식의 튜플 만들기| `tuple3=1,2,3,4` |
|리스트로부터 튜플 만들기| `n_list=[1,2,3,4]; tuple4=tuple(n_list)` |

- 튜플은 할당 연산자를 이용해 Packing과 UnPacking을 할 수 있다.
    - 패킹 : 하나의 튜플 변수에 여러개의 값을 넣는 것
    - 언패킹 : 패킹된 변수로부터 여러개의 값을 개별 변수에 담아 꺼내는 것
    
    |패킹|언패킹|
    |--|--|
    |`a=(1,2)` # 튜플패킹|`c=(3,4)` # 튜플 패킹|
    |`a[0]` # 튜플 항목에 대한 참조|`d, e=c` # 튜플 언패킹|

    ## 튜플을 이용한 swap
    ```py
    a = 100
    b = 200

    a, b = b, a
    
    # >> a=200, b=100
    ```

    ## 튜플과 연산자 ?
    ```py
    t0 = (10, 20, 30)
    t1 = t0 + t0
    # >> (10, 20, 30, 10, 20, 30)

    t2 = t0 * 2
    # >> (10, 20, 30, 10, 20, 30)

    # t3 = t0 + 40 정수와의 덧셈연산 불가

    t4 = t0 + (40,)
    # >> (10, 20, 30, 40)
    ```

# 집합 set ?
- 순서가 없는 자료형
- 동일한 값을 가지는 항목의 중복이 허용X
- 교집합, 합집합, 차집합, 대칭차집합 같은 다양한 연산 가능

|집합 생성 방법| 명령어|
|--|--|
|빈 집합 만들기| `set0=set()` |
|기본적인 집합 만들기| `set1 = {1,2,3,4}` |
|튜플로부터 집합 만들기| `n_tuple={1,2,3,4}; set2=set(n_tuple)` |
|리스트로부터 집합 만들기| `n_list=[1,2,3,4]; set3=set(n_list)` |

- 집합은 순서가 없는 원소의 모임으로 인덱스를 사용할 수 없다. => 슬라이싱도 불가

# `zip()` ?
- `iterable` 반복 가능한 자료형인 리스트, 딕셔너리, 집합, 튜플들 여러개를 넘겨주면 이들을 합쳐 튜플 iterator 반복자를 반환하는 함수가 `zip`이다.
- `zip(*iterables)`
- 인자가 전달되지 않으면 공백 반복자를 반환함.
- 하나의 반복 가능한 자료형 인자가 들어올 경우 튜플형 반복 가능한 자료형 반환함
- 인자로 넘어온 데이터에서 얻어진 값 하나씩이 전달됨
- 다수의 반복 가능한 자료형 인자가 n개 들어오면 튜플 반복자는 인자수인 n개 만큼의 튜플을 원소로 가진 튜플 반복자가 된다.
> `zip` 결과는 튜플이다.
```py
empty_iterator = zip()
result = set(empty_iterator)
result
# >> set()

a = [10, 20, 30]
b = ('ten', 'twenty', 'thirty')
for val in zip(a, b):
    print(val)

# >> (10, 'ten')
# >> (20, 'twenty')
# >> (30, 'thirty')
```

## zip으로 묶여진 튜플을 언패킹하기
```py
zip_lst = list(zip(str_list, int_tuple, int_list))
a, b, c = zip(*zip_lst)
```

## 튜플과 슬라이싱 ??
```py
tu = (0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
tu[1:5]
# >> (1, 2, 3, 4)
tu[0:10:3]
# >> (0, 3, 6, 9)
tu[::-1]
# >> (9, 8, 7, 6, 5, 4, 3, 2, 1, 0)
```

## 문자열과 슬라이싱 ??
```py
text = "hello world"
text[1:5]
# >> 'ello'
text[6:]
# >> 'world'
text[::3]
# >> 'hlwl'
text[::-1]
# >> 'dlrow olleh'
```